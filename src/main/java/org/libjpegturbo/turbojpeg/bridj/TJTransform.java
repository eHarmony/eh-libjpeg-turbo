package org.libjpegturbo.turbojpeg.bridj;

import org.bridj.BridJ;
import org.bridj.Callback;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;

/**
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a
 * href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("turbojpeg")
public class TJTransform extends StructObject {
    static {
        BridJ.register();
    }

    /**
     * Cropping region<br>
     * C type : tjregion
     */
    @Field(0)
    public TJRegion r() {
        return this.io.getNativeObjectField(this, 0);
    }

    /**
     * Cropping region<br>
     * C type : tjregion
     */
    @Field(0)
    public TJTransform r(TJRegion r) {
        this.io.setNativeObjectField(this, 0, r);
        return this;
    }

    /** One of the @ref TJXOP "transform operations" */
    @Field(1)
    public int op() {
        return this.io.getIntField(this, 1);
    }

    /** One of the @ref TJXOP "transform operations" */
    @Field(1)
    public TJTransform op(int op) {
        this.io.setIntField(this, 1, op);
        return this;
    }

    /** The bitwise OR of one of more of the @ref TJXOPT_CROP "transform options" */
    @Field(2)
    public int options() {
        return this.io.getIntField(this, 2);
    }

    /** The bitwise OR of one of more of the @ref TJXOPT_CROP "transform options" */
    @Field(2)
    public TJTransform options(int options) {
        this.io.setIntField(this, 2, options);
        return this;
    }

    /**
     * Arbitrary data that can be accessed within the body of the callback<br>
     * function<br>
     * C type : void*
     */
    @Field(3)
    public Pointer<?> data() {
        return this.io.getPointerField(this, 3);
    }

    /**
     * Arbitrary data that can be accessed within the body of the callback<br>
     * function<br>
     * C type : void*
     */
    @Field(3)
    public TJTransform data(Pointer<?> data) {
        this.io.setPointerField(this, 3, data);
        return this;
    }

    /**
     * A callback function that can be used to modify the DCT coefficients<br>
     * after they are losslessly transformed but before they are transcoded to a<br>
     * new JPEG image. This allows for custom filters or other transformations<br>
     * to be applied in the frequency domain.<br>
     * * @param coeffs pointer to an array of transformed DCT coefficients. (NOTE:<br>
     * this pointer is not guaranteed to be valid once the callback returns, so<br>
     * applications wishing to hand off the DCT coefficients to another function<br>
     * or library should make a copy of them within the body of the callback.)<br>
     * * @param arrayRegion #tjregion structure containing the width and height of<br>
     * the array pointed to by <tt>coeffs</tt> as well as its offset relative to<br>
     * the component plane. TurboJPEG implementations may choose to split each<br>
     * component plane into multiple DCT coefficient arrays and call the callback<br>
     * function once for each array.<br>
     * * @param planeRegion #tjregion structure containing the width and height of<br>
     * the component plane to which <tt>coeffs</tt> belongs<br>
     * * @param componentID ID number of the component plane to which<br>
     * <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,<br>
     * and 2 in typical JPEG images.)<br>
     * * @param transformID ID number of the transformed image to which<br>
     * <tt>coeffs</tt> belongs. This is the same as the index of the transform<br>
     * in the <tt>transforms</tt> array that was passed to #tjTransform().<br>
     * * @param transform a pointer to a #tjtransform structure that specifies the<br>
     * parameters and/or cropping region for this transform<br>
     * * @return 0 if the callback was successful, or -1 if an error occurred.<br>
     * C type : CustomFilterCallback*
     */
    @Field(4)
    public Pointer<TJTransform.CustomFilterCallback> customFilter() {
        return this.io.getPointerField(this, 4);
    }

    /**
     * A callback function that can be used to modify the DCT coefficients<br>
     * after they are losslessly transformed but before they are transcoded to a<br>
     * new JPEG image. This allows for custom filters or other transformations<br>
     * to be applied in the frequency domain.<br>
     * * @param coeffs pointer to an array of transformed DCT coefficients. (NOTE:<br>
     * this pointer is not guaranteed to be valid once the callback returns, so<br>
     * applications wishing to hand off the DCT coefficients to another function<br>
     * or library should make a copy of them within the body of the callback.)<br>
     * * @param arrayRegion #tjregion structure containing the width and height of<br>
     * the array pointed to by <tt>coeffs</tt> as well as its offset relative to<br>
     * the component plane. TurboJPEG implementations may choose to split each<br>
     * component plane into multiple DCT coefficient arrays and call the callback<br>
     * function once for each array.<br>
     * * @param planeRegion #tjregion structure containing the width and height of<br>
     * the component plane to which <tt>coeffs</tt> belongs<br>
     * * @param componentID ID number of the component plane to which<br>
     * <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,<br>
     * and 2 in typical JPEG images.)<br>
     * * @param transformID ID number of the transformed image to which<br>
     * <tt>coeffs</tt> belongs. This is the same as the index of the transform<br>
     * in the <tt>transforms</tt> array that was passed to #tjTransform().<br>
     * * @param transform a pointer to a #tjtransform structure that specifies the<br>
     * parameters and/or cropping region for this transform<br>
     * * @return 0 if the callback was successful, or -1 if an error occurred.<br>
     * C type : CustomFilterCallback*
     */
    @Field(4)
    public TJTransform customFilter(Pointer<TJTransform.CustomFilterCallback> customFilter) {
        this.io.setPointerField(this, 4, customFilter);
        return this;
    }

    public static abstract class CustomFilterCallback extends Callback<CustomFilterCallback> {
        public abstract int apply(Pointer<Short> coeffs, TJRegion arrayRegion, TJRegion planeRegion,
                int componentIndex, int transformIndex, Pointer<TJTransform> transform);
    };

    public TJTransform() {
        super();
    }

    public TJTransform(Pointer pointer) {
        super(pointer);
    }
}
