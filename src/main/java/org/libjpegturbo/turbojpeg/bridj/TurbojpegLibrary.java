package org.libjpegturbo.turbojpeg.bridj;

import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Runtime;

/**
 * Wrapper for library <b>turbojpeg</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a
 * href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("turbojpeg")
@Runtime(CRuntime.class)
public class TurbojpegLibrary {
    static {
        BridJ.register();
    }

    /**
     * Chrominance subsampling options.<br>
     * When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK<br>
     * to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of<br>
     * the Cb and Cr (chrominance) components can be discarded or averaged together<br>
     * to produce a smaller image with little perceptible loss of image clarity<br>
     * (the human eye is more sensitive to small changes in brightness than to<br>
     * small changes in color.) This is called "chrominance subsampling".<br>
     * enum values<br>
     * <i>native declaration : line 93</i>
     */
    public enum TJSAMP implements IntValuedEnum<TJSAMP> {
        /**
         * 4:4:4 chrominance subsampling (no chrominance subsampling). The JPEG or<br>
         * YUV image will contain one chrominance component for every pixel in the<br>
         * source image.
         */
        TJSAMP_444(0),
        /**
         * 4:2:2 chrominance subsampling. The JPEG or YUV image will contain one<br>
         * chrominance component for every 2x1 block of pixels in the source image.
         */
        TJSAMP_422(1),
        /**
         * 4:2:0 chrominance subsampling. The JPEG or YUV image will contain one<br>
         * chrominance component for every 2x2 block of pixels in the source image.
         */
        TJSAMP_420(2),
        /** Grayscale. The JPEG or YUV image will contain no chrominance components. */
        TJSAMP_GRAY(3),
        /**
         * 4:4:0 chrominance subsampling. The JPEG or YUV image will contain one<br>
         * chrominance component for every 1x2 block of pixels in the source image.<br>
         * * @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.
         */
        TJSAMP_440(4),
        /**
         * 4:1:1 chrominance subsampling. The JPEG or YUV image will contain one<br>
         * chrominance component for every 4x1 block of pixels in the source image.<br>
         * JPEG images compressed with 4:1:1 subsampling will be almost exactly the<br>
         * same size as those compressed with 4:2:0 subsampling, and in the<br>
         * aggregate, both subsampling methods produce approximately the same<br>
         * perceptual quality. However, 4:1:1 is better able to reproduce sharp<br>
         * horizontal features.<br>
         * * @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo.
         */
        TJSAMP_411(5);
        TJSAMP(long value) {
            this.value = value;
        }

        public final long value;

        public long value() {
            return this.value;
        }

        public Iterator<TJSAMP> iterator() {
            return Collections.singleton(this).iterator();
        }

        public static IntValuedEnum<TJSAMP> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };

    /**
     * Pixel formats<br>
     * enum values<br>
     * <i>native declaration : line 167</i>
     */
    public enum TJPF implements IntValuedEnum<TJPF> {
        /**
         * RGB pixel format. The red, green, and blue components in the image are<br>
         * stored in 3-byte pixels in the order R, G, B from lowest to highest byte<br>
         * address within each pixel.
         */
        TJPF_RGB(0),
        /**
         * BGR pixel format. The red, green, and blue components in the image are<br>
         * stored in 3-byte pixels in the order B, G, R from lowest to highest byte<br>
         * address within each pixel.
         */
        TJPF_BGR(1),
        /**
         * RGBX pixel format. The red, green, and blue components in the image are<br>
         * stored in 4-byte pixels in the order R, G, B from lowest to highest byte<br>
         * address within each pixel. The X component is ignored when compressing<br>
         * and undefined when decompressing.
         */
        TJPF_RGBX(2),
        /**
         * BGRX pixel format. The red, green, and blue components in the image are<br>
         * stored in 4-byte pixels in the order B, G, R from lowest to highest byte<br>
         * address within each pixel. The X component is ignored when compressing<br>
         * and undefined when decompressing.
         */
        TJPF_BGRX(3),
        /**
         * XBGR pixel format. The red, green, and blue components in the image are<br>
         * stored in 4-byte pixels in the order R, G, B from highest to lowest byte<br>
         * address within each pixel. The X component is ignored when compressing<br>
         * and undefined when decompressing.
         */
        TJPF_XBGR(4),
        /**
         * XRGB pixel format. The red, green, and blue components in the image are<br>
         * stored in 4-byte pixels in the order B, G, R from highest to lowest byte<br>
         * address within each pixel. The X component is ignored when compressing<br>
         * and undefined when decompressing.
         */
        TJPF_XRGB(5),
        /**
         * Grayscale pixel format. Each 1-byte pixel represents a luminance<br>
         * (brightness) level from 0 to 255.
         */
        TJPF_GRAY(6),
        /**
         * RGBA pixel format. This is the same as @ref TJPF_RGBX, except that when<br>
         * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
         * interpreted as an opaque alpha channel.
         */
        TJPF_RGBA(7),
        /**
         * BGRA pixel format. This is the same as @ref TJPF_BGRX, except that when<br>
         * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
         * interpreted as an opaque alpha channel.
         */
        TJPF_BGRA(8),
        /**
         * ABGR pixel format. This is the same as @ref TJPF_XBGR, except that when<br>
         * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
         * interpreted as an opaque alpha channel.
         */
        TJPF_ABGR(9),
        /**
         * ARGB pixel format. This is the same as @ref TJPF_XRGB, except that when<br>
         * decompressing, the X component is guaranteed to be 0xFF, which can be<br>
         * interpreted as an opaque alpha channel.
         */
        TJPF_ARGB(10),
        /**
         * CMYK pixel format. Unlike RGB, which is an additive color model used<br>
         * primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive<br>
         * color model used primarily for printing. In the CMYK color model, the<br>
         * value of each color component typically corresponds to an amount of cyan,<br>
         * magenta, yellow, or black ink that is applied to a white background. In<br>
         * order to convert between CMYK and RGB, it is necessary to use a color<br>
         * management system (CMS.) A CMS will attempt to map colors within the<br>
         * printer's gamut to perceptually similar colors in the display's gamut and<br>
         * vice versa, but the mapping is typically not 1:1 or reversible, nor can it<br>
         * be defined with a simple formula. Thus, such a conversion is out of scope<br>
         * for a codec library. However, the TurboJPEG API allows for compressing<br>
         * CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK<br>
         * JPEG images into CMYK pixels.
         */
        TJPF_CMYK(11);
        TJPF(long value) {
            this.value = value;
        }

        public final long value;

        public long value() {
            return this.value;
        }

        public Iterator<TJPF> iterator() {
            return Collections.singleton(this).iterator();
        }

        public static IntValuedEnum<TJPF> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };

    /**
     * JPEG colorspaces<br>
     * enum values<br>
     * <i>native declaration : line 294</i>
     */
    public enum TJCS implements IntValuedEnum<TJCS> {
        /**
         * RGB colorspace. When compressing the JPEG image, the R, G, and B<br>
         * components in the source image are reordered into image planes, but no<br>
         * colorspace conversion or subsampling is performed. RGB JPEG images can be<br>
         * decompressed to any of the extended RGB pixel formats or grayscale, but<br>
         * they cannot be decompressed to YUV images.
         */
        TJCS_RGB(0),
        /**
         * YCbCr colorspace. YCbCr is not an absolute colorspace but rather a<br>
         * mathematical transformation of RGB designed solely for storage and<br>
         * transmission. YCbCr images must be converted to RGB before they can<br>
         * actually be displayed. In the YCbCr colorspace, the Y (luminance)<br>
         * component represents the black & white portion of the original image, and<br>
         * the Cb and Cr (chrominance) components represent the color portion of the<br>
         * original image. Originally, the analog equivalent of this transformation<br>
         * allowed the same signal to drive both black & white and color televisions,<br>
         * but JPEG images use YCbCr primarily because it allows the color data to be<br>
         * optionally subsampled for the purposes of reducing bandwidth or disk<br>
         * space. YCbCr is the most common JPEG colorspace, and YCbCr JPEG images<br>
         * can be compressed from and decompressed to any of the extended RGB pixel<br>
         * formats or grayscale, or they can be decompressed to YUV planar images.
         */
        TJCS_YCbCr(1),
        /**
         * Grayscale colorspace. The JPEG image retains only the luminance data (Y<br>
         * component), and any color data from the source image is discarded.<br>
         * Grayscale JPEG images can be compressed from and decompressed to any of<br>
         * the extended RGB pixel formats or grayscale, or they can be decompressed<br>
         * to YUV planar images.
         */
        TJCS_GRAY(2),
        /**
         * CMYK colorspace. When compressing the JPEG image, the C, M, Y, and K<br>
         * components in the source image are reordered into image planes, but no<br>
         * colorspace conversion or subsampling is performed. CMYK JPEG images can<br>
         * only be decompressed to CMYK pixels.
         */
        TJCS_CMYK(3),
        /**
         * YCCK colorspace. YCCK (AKA "YCbCrK") is not an absolute colorspace but<br>
         * rather a mathematical transformation of CMYK designed solely for storage<br>
         * and transmission. It is to CMYK as YCbCr is to RGB. CMYK pixels can be<br>
         * reversibly transformed into YCCK, and as with YCbCr, the chrominance<br>
         * components in the YCCK pixels can be subsampled without incurring major<br>
         * perceptual loss. YCCK JPEG images can only be compressed from and<br>
         * decompressed to CMYK pixels.
         */
        TJCS_YCCK(4);
        TJCS(long value) {
            this.value = value;
        }

        public final long value;

        public long value() {
            return this.value;
        }

        public Iterator<TJCS> iterator() {
            return Collections.singleton(this).iterator();
        }

        public static IntValuedEnum<TJCS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };

    /**
     * Transform operations for #tjTransform()<br>
     * enum values<br>
     * <i>native declaration : line 397</i>
     */
    public enum TJXOP implements IntValuedEnum<TJXOP> {
        /** Do not transform the position of the image pixels */
        TJXOP_NONE(0),
        /**
         * Flip (mirror) image horizontally. This transform is imperfect if there<br>
         * are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)
         */
        TJXOP_HFLIP(1),
        /**
         * Flip (mirror) image vertically. This transform is imperfect if there are<br>
         * any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)
         */
        TJXOP_VFLIP(2),
        /**
         * Transpose image (flip/mirror along upper left to lower right axis.) This<br>
         * transform is always perfect.
         */
        TJXOP_TRANSPOSE(3),
        /**
         * Transverse transpose image (flip/mirror along upper right to lower left<br>
         * axis.) This transform is imperfect if there are any partial MCU blocks in<br>
         * the image (see #TJXOPT_PERFECT.)
         */
        TJXOP_TRANSVERSE(4),
        /**
         * Rotate image clockwise by 90 degrees. This transform is imperfect if<br>
         * there are any partial MCU blocks on the bottom edge (see<br>
         * #TJXOPT_PERFECT.)
         */
        TJXOP_ROT90(5),
        /**
         * Rotate image 180 degrees. This transform is imperfect if there are any<br>
         * partial MCU blocks in the image (see #TJXOPT_PERFECT.)
         */
        TJXOP_ROT180(6),
        /**
         * Rotate image counter-clockwise by 90 degrees. This transform is imperfect<br>
         * if there are any partial MCU blocks on the right edge (see<br>
         * #TJXOPT_PERFECT.)
         */
        TJXOP_ROT270(7);
        TJXOP(long value) {
            this.value = value;
        }

        public final long value;

        public long value() {
            return this.value;
        }

        public Iterator<TJXOP> iterator() {
            return Collections.singleton(this).iterator();
        }

        public static IntValuedEnum<TJXOP> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };

    public static final int TJXOPT_TRIM = (int) 2;
    public static final int TJ_NUMSAMP = (int) 6;
    public static final int NUMSUBOPT = (int) 6;
    public static final int TJFLAG_ACCURATEDCT = (int) 4096;
    public static final int TJFLAG_FORCEMMX = (int) 8;
    public static final int TJFLAG_FASTDCT = (int) 2048;
    public static final int TJ_NUMXOP = (int) 8;
    public static final int TJFLAG_FORCESSE = (int) 16;
    public static final int TJ_NUMPF = (int) 12;
    public static final int TJ_FORCEMMX = (int) 8;
    public static final int TJ_NUMCS = (int) 5;
    public static final int TJXOPT_CROP = (int) 4;
    public static final int TJFLAG_FASTUPSAMPLE = (int) 256;
    public static final int TJ_FASTUPSAMPLE = (int) 256;
    public static final int TJFLAG_FORCESSE2 = (int) 32;
    public static final int TJFLAG_FORCESSE3 = (int) 128;
    public static final int TJ_ALPHAFIRST = (int) 64;
    public static final int TJXOPT_PERFECT = (int) 1;
    public static final int TJ_FORCESSE2 = (int) 32;
    public static final int TJ_BOTTOMUP = (int) 2;
    public static final int TJ_FORCESSE3 = (int) 128;
    public static final int TJXOPT_GRAY = (int) 8;
    public static final int TJ_FORCESSE = (int) 16;
    public static final int TJ_YUV = (int) 512;
    public static final int TJXOPT_NOOUTPUT = (int) 16;
    public static final int TJFLAG_NOREALLOC = (int) 1024;
    public static final int TJ_BGR = (int) 1;
    public static final int TJFLAG_BOTTOMUP = (int) 2;

    /**
     * Create a TurboJPEG compressor instance.<br>
     * * @return a handle to the newly-created instance, or NULL if an error<br>
     * occurred (see #tjGetErrorStr().)<br>
     * Original signature : <code>tjhandle tjInitCompress()</code><br>
     * <i>native declaration : line 614</i>
     */
    public static native Pointer<?> tjInitCompress();

    /**
     * Compress an RGB, grayscale, or CMYK image into a JPEG image.<br>
     * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
     * * @param srcBuf pointer to an image buffer containing RGB, grayscale, or<br>
     * CMYK pixels to be compressed<br>
     * * @param width width (in pixels) of the source image<br>
     * * @param pitch bytes per line in the source image. Normally, this should be<br>
     * <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or<br>
     * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image<br>
     * is padded to the nearest 32-bit boundary, as is the case for Windows<br>
     * bitmaps. You can also be clever and use this parameter to skip lines, etc.<br>
     * Setting this parameter to 0 is the equivalent of setting it to<br>
     * <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
     * * @param height height (in pixels) of the source image<br>
     * * @param pixelFormat pixel format of the source image (see @ref TJPF<br>
     * "Pixel formats".)<br>
     * * @param jpegBuf address of a pointer to an image buffer that will receive the<br>
     * JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer<br>
     * to accommodate the size of the JPEG image. Thus, you can choose to:<br>
     * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and<br>
     * let TurboJPEG grow the buffer as needed,<br>
     * -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer<br>
     * for you, or<br>
     * -# pre-allocate the buffer to a "worst case" size determined by calling<br>
     * #tjBufSize(). This should ensure that the buffer never has to be<br>
     * re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)<br>
     * .<br>
     * If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your<br>
     * pre-allocated buffer. In any case, unless you have set #TJFLAG_NOREALLOC,<br>
     * you should always check <tt>*jpegBuf</tt> upon return from this function, as<br>
     * it may have changed.<br>
     * * @param jpegSize pointer to an unsigned long variable that holds the size of<br>
     * the JPEG image buffer. If <tt>*jpegBuf</tt> points to a pre-allocated<br>
     * buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.<br>
     * Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in<br>
     * bytes.) If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being<br>
     * reused from a previous call to one of the JPEG compression functions, then<br>
     * <tt>*jpegSize</tt> is ignored.<br>
     * * @param jpegSubsamp the level of chrominance subsampling to be used when<br>
     * generating the JPEG image (see @ref TJSAMP<br>
     * "Chrominance subsampling options".)<br>
     * * @param jpegQual the image quality of the generated JPEG image (1 = worst,<br>
     * 100 = best)<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjCompress2(tjhandle, const unsigned char*, int, int, int, int, unsigned char**, unsigned long*, int, int, int)</code>
     * <br>
     * <i>native declaration : line 676</i>
     */
    public static native int tjCompress2(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pitch, int height,
            int pixelFormat, Pointer<Pointer<Byte>> jpegBuf, Pointer<org.bridj.CLong> jpegSize, int jpegSubsamp,
            int jpegQual, int flags);

    /**
     * Compress a YUV planar image into a JPEG image.<br>
     * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
     * * @param srcBuf pointer to an image buffer containing a YUV planar image to be<br>
     * compressed. The size of this buffer should match the value returned by<br>
     * #tjBufSizeYUV2() for the given image width, height, padding, and level of<br>
     * chrominance subsampling. The Y, U (Cb), and V (Cr) image planes should be<br>
     * stored sequentially in the source buffer (refer to @ref YUVnotes<br>
     * "YUV Image Format Notes".)<br>
     * * @param width width (in pixels) of the source image. If the width is not an<br>
     * even multiple of the MCU block width (see #tjMCUWidth), then an intermediate<br>
     * buffer copy will be performed within TurboJPEG.<br>
     * * @param pad the line padding used in the source image. For instance, if each<br>
     * line in each plane of the YUV image is padded to the nearest multiple of 4<br>
     * bytes, then <tt>pad</tt> should be set to 4.<br>
     * * @param height height (in pixels) of the source image. If the height is not<br>
     * an even multiple of the MCU block height (see #tjMCUHeight), then an<br>
     * intermediate buffer copy will be performed within TurboJPEG.<br>
     * * @param subsamp the level of chrominance subsampling used in the source<br>
     * image (see @ref TJSAMP "Chrominance subsampling options".)<br>
     * * @param jpegBuf address of a pointer to an image buffer that will receive the<br>
     * JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to<br>
     * accommodate the size of the JPEG image. Thus, you can choose to:<br>
     * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and<br>
     * let TurboJPEG grow the buffer as needed,<br>
     * -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer<br>
     * for you, or<br>
     * -# pre-allocate the buffer to a "worst case" size determined by calling<br>
     * #tjBufSize(). This should ensure that the buffer never has to be<br>
     * re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)<br>
     * .<br>
     * If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your<br>
     * pre-allocated buffer. In any case, unless you have set #TJFLAG_NOREALLOC,<br>
     * you should always check <tt>*jpegBuf</tt> upon return from this function, as<br>
     * it may have changed.<br>
     * * @param jpegSize pointer to an unsigned long variable that holds the size of<br>
     * the JPEG image buffer. If <tt>*jpegBuf</tt> points to a pre-allocated<br>
     * buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.<br>
     * Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in<br>
     * bytes.) If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being<br>
     * reused from a previous call to one of the JPEG compression functions, then<br>
     * <tt>*jpegSize</tt> is ignored.<br>
     * * @param jpegQual the image quality of the generated JPEG image (1 = worst,<br>
     * 100 = best)<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjCompressFromYUV(tjhandle, const unsigned char*, int, int, int, int, unsigned char**, unsigned long*, int, int)</code>
     * <br>
     * <i>native declaration : line 740</i>
     */
    public static native int tjCompressFromYUV(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pad, int height,
            int subsamp, Pointer<Pointer<Byte>> jpegBuf, Pointer<org.bridj.CLong> jpegSize, int jpegQual, int flags);

    /**
     * Compress a set of Y, U (Cb), and V (Cr) image planes into a JPEG image.<br>
     * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
     * * @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes<br>
     * (or just a Y plane, if compressing a grayscale image) that contain a YUV<br>
     * image to be compressed. These planes can be contiguous or non-contiguous in<br>
     * memory. The size of each plane should match the value returned by<br>
     * #tjPlaneSizeYUV() for the given image width, height, strides, and level of<br>
     * chrominance subsampling. Refer to @ref YUVnotes "YUV Image Format Notes"<br>
     * for more details.<br>
     * * @param width width (in pixels) of the source image. If the width is not an<br>
     * even multiple of the MCU block width (see #tjMCUWidth), then an intermediate<br>
     * buffer copy will be performed within TurboJPEG.<br>
     * * @param strides an array of integers, each specifying the number of bytes per<br>
     * line in the corresponding plane of the YUV source image. Setting the stride<br>
     * for any plane to 0 is the same as setting it to the plane width (see<br>
     * 
     * @ref YUVnotes "YUV Image Format Notes".) If <tt>strides</tt> is NULL, then<br>
     *      the strides for all planes will be set to their respective plane widths.<br>
     *      You can adjust the strides in order to specify an arbitrary amount of line<br>
     *      padding in each plane or to create a JPEG image from a subregion of a larger<br>
     *      YUV planar image.<br>
     *      * @param height height (in pixels) of the source image. If the height is not<br>
     *      an even multiple of the MCU block height (see #tjMCUHeight), then an<br>
     *      intermediate buffer copy will be performed within TurboJPEG.<br>
     *      * @param subsamp the level of chrominance subsampling used in the source<br>
     *      image (see @ref TJSAMP "Chrominance subsampling options".)<br>
     *      * @param jpegBuf address of a pointer to an image buffer that will receive the<br>
     *      JPEG image. TurboJPEG has the ability to reallocate the JPEG buffer to<br>
     *      accommodate the size of the JPEG image. Thus, you can choose to:<br>
     *      -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and<br>
     *      let TurboJPEG grow the buffer as needed,<br>
     *      -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer<br>
     *      for you, or<br>
     *      -# pre-allocate the buffer to a "worst case" size determined by calling<br>
     *      #tjBufSize(). This should ensure that the buffer never has to be<br>
     *      re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)<br>
     *      .<br>
     *      If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your<br>
     *      pre-allocated buffer. In any case, unless you have set #TJFLAG_NOREALLOC,<br>
     *      you should always check <tt>*jpegBuf</tt> upon return from this function, as<br>
     *      it may have changed.<br>
     *      * @param jpegSize pointer to an unsigned long variable that holds the size of<br>
     *      the JPEG image buffer. If <tt>*jpegBuf</tt> points to a pre-allocated<br>
     *      buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.<br>
     *      Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in<br>
     *      bytes.) If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being<br>
     *      reused from a previous call to one of the JPEG compression functions, then<br>
     *      <tt>*jpegSize</tt> is ignored.<br>
     *      * @param jpegQual the image quality of the generated JPEG image (1 = worst,<br>
     *      100 = best)<br>
     *      * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     *      "flags"<br>
     *      * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     *      Original signature :
     *      <code>int tjCompressFromYUVPlanes(tjhandle, const unsigned char**, int, const int*, int, int, unsigned char**, unsigned long*, int, int)</code>
     * <br>
     *      <i>native declaration : line 810</i>
     */
    public static native int tjCompressFromYUVPlanes(Pointer<?> handle, Pointer<Pointer<Byte>> srcPlanes, int width,
            Pointer<Integer> strides, int height, int subsamp, Pointer<Pointer<Byte>> jpegBuf,
            Pointer<org.bridj.CLong> jpegSize, int jpegQual, int flags);

    /**
     * The maximum size of the buffer (in bytes) required to hold a JPEG image with<br>
     * the given parameters. The number of bytes returned by this function is<br>
     * larger than the size of the uncompressed source image. The reason for this<br>
     * is that the JPEG format uses 16-bit coefficients, and it is thus possible<br>
     * for a very high-quality JPEG image with very high-frequency content to<br>
     * expand rather than compress when converted to the JPEG format. Such images<br>
     * represent a very rare corner case, but since there is no way to predict the<br>
     * size of a JPEG image prior to compression, the corner case has to be<br>
     * handled.<br>
     * * @param width width (in pixels) of the image<br>
     * * @param height height (in pixels) of the image<br>
     * * @param jpegSubsamp the level of chrominance subsampling to be used when<br>
     * generating the JPEG image (see @ref TJSAMP<br>
     * "Chrominance subsampling options".)<br>
     * * @return the maximum size of the buffer (in bytes) required to hold the<br>
     * image, or -1 if the arguments are out of bounds.<br>
     * Original signature : <code>long tjBufSize(int, int, int)</code><br>
     * <i>native declaration : line 838</i>
     */
    @org.bridj.ann.CLong
    public static native long tjBufSize(int width, int height, int jpegSubsamp);

    /**
     * The size of the buffer (in bytes) required to hold a YUV planar image with<br>
     * the given parameters.<br>
     * * @param width width (in pixels) of the image<br>
     * * @param pad the width of each line in each plane of the image is padded to<br>
     * the nearest multiple of this number of bytes (must be a power of 2.)<br>
     * * @param height height (in pixels) of the image<br>
     * * @param subsamp level of chrominance subsampling in the image (see<br>
     * 
     * @ref TJSAMP "Chrominance subsampling options".)<br>
     *      * @return the size of the buffer (in bytes) required to hold the image, or<br>
     *      -1 if the arguments are out of bounds.<br>
     *      Original signature : <code>long tjBufSizeYUV2(int, int, int, int)</code><br>
     *      <i>native declaration : line 859</i>
     */
    @org.bridj.ann.CLong
    public static native long tjBufSizeYUV2(int width, int pad, int height, int subsamp);

    /**
     * The size of the buffer (in bytes) required to hold a YUV image plane with<br>
     * the given parameters.<br>
     * * @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)<br>
     * * @param width width (in pixels) of the YUV image. NOTE: this is the width of<br>
     * the whole image, not the plane width.<br>
     * * @param stride bytes per line in the image plane. Setting this to 0 is the<br>
     * equivalent of setting it to the plane width.<br>
     * * @param height height (in pixels) of the YUV image. NOTE: this is the height<br>
     * of the whole image, not the plane height.<br>
     * * @param subsamp level of chrominance subsampling in the image (see<br>
     * 
     * @ref TJSAMP "Chrominance subsampling options".)<br>
     *      * @return the size of the buffer (in bytes) required to hold the YUV image<br>
     *      plane, or -1 if the arguments are out of bounds.<br>
     *      Original signature : <code>long tjPlaneSizeYUV(int, int, int, int, int)</code><br>
     *      <i>native declaration : line 884</i>
     */
    @org.bridj.ann.CLong
    public static native long tjPlaneSizeYUV(int componentID, int width, int stride, int height, int subsamp);

    /**
     * The plane width of a YUV image plane with the given parameters. Refer to<br>
     * 
     * @ref YUVnotes "YUV Image Format Notes" for a description of plane width.<br>
     *      * @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)<br>
     *      * @param width width (in pixels) of the YUV image<br>
     *      * @param subsamp level of chrominance subsampling in the image (see<br>
     * @ref TJSAMP "Chrominance subsampling options".)<br>
     *      * @return the plane width of a YUV image plane with the given parameters, or<br>
     *      -1 if the arguments are out of bounds.<br>
     *      Original signature : <code>int tjPlaneWidth(int, int, int)</code><br>
     *      <i>native declaration : line 902</i>
     */
    public static native int tjPlaneWidth(int componentID, int width, int subsamp);

    /**
     * The plane height of a YUV image plane with the given parameters. Refer to<br>
     * 
     * @ref YUVnotes "YUV Image Format Notes" for a description of plane height.<br>
     *      * @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)<br>
     *      * @param height height (in pixels) of the YUV image<br>
     *      * @param subsamp level of chrominance subsampling in the image (see<br>
     * @ref TJSAMP "Chrominance subsampling options".)<br>
     *      * @return the plane height of a YUV image plane with the given parameters, or<br>
     *      -1 if the arguments are out of bounds.<br>
     *      Original signature : <code>int tjPlaneHeight(int, int, int)</code><br>
     *      <i>native declaration : line 919</i>
     */
    public static native int tjPlaneHeight(int componentID, int height, int subsamp);

    /**
     * Encode an RGB or grayscale image into a YUV planar image. This function<br>
     * uses the accelerated color conversion routines in the underlying<br>
     * codec but does not execute any of the other steps in the JPEG compression<br>
     * process.<br>
     * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
     * * @param srcBuf pointer to an image buffer containing RGB or grayscale pixels<br>
     * to be encoded<br>
     * * @param width width (in pixels) of the source image<br>
     * * @param pitch bytes per line in the source image. Normally, this should be<br>
     * <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or<br>
     * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image<br>
     * is padded to the nearest 32-bit boundary, as is the case for Windows<br>
     * bitmaps. You can also be clever and use this parameter to skip lines, etc.<br>
     * Setting this parameter to 0 is the equivalent of setting it to<br>
     * <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
     * * @param height height (in pixels) of the source image<br>
     * * @param pixelFormat pixel format of the source image (see @ref TJPF<br>
     * "Pixel formats".)<br>
     * * @param dstBuf pointer to an image buffer that will receive the YUV image.<br>
     * Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based<br>
     * on the image width, height, padding, and level of chrominance subsampling.<br>
     * The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the<br>
     * buffer (refer to @ref YUVnotes "YUV Image Format Notes".)<br>
     * * @param pad the width of each line in each plane of the YUV image will be<br>
     * padded to the nearest multiple of this number of bytes (must be a power of<br>
     * 2.) To generate images suitable for X Video, <tt>pad</tt> should be set to<br>
     * 4.<br>
     * * @param subsamp the level of chrominance subsampling to be used when<br>
     * generating the YUV image (see @ref TJSAMP<br>
     * "Chrominance subsampling options".) To generate images suitable for X<br>
     * Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420. This produces an<br>
     * image compatible with the I420 (AKA "YUV420P") format.<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjEncodeYUV3(tjhandle, const unsigned char*, int, int, int, int, unsigned char*, int, int, int)</code><br>
     * <i>native declaration : line 970</i>
     */
    public static native int tjEncodeYUV3(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pitch, int height,
            int pixelFormat, Pointer<Byte> dstBuf, int pad, int subsamp, int flags);

    /**
     * Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image<br>
     * planes. This function uses the accelerated color conversion routines in the<br>
     * underlying codec but does not execute any of the other steps in the JPEG<br>
     * compression process.<br>
     * * @param handle a handle to a TurboJPEG compressor or transformer instance<br>
     * * @param srcBuf pointer to an image buffer containing RGB or grayscale pixels<br>
     * to be encoded<br>
     * * @param width width (in pixels) of the source image<br>
     * * @param pitch bytes per line in the source image. Normally, this should be<br>
     * <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or<br>
     * <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image<br>
     * is padded to the nearest 32-bit boundary, as is the case for Windows<br>
     * bitmaps. You can also be clever and use this parameter to skip lines, etc.<br>
     * Setting this parameter to 0 is the equivalent of setting it to<br>
     * <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
     * * @param height height (in pixels) of the source image<br>
     * * @param pixelFormat pixel format of the source image (see @ref TJPF<br>
     * "Pixel formats".)<br>
     * * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes<br>
     * (or just a Y plane, if generating a grayscale image) that will receive the<br>
     * encoded image. These planes can be contiguous or non-contiguous in memory.<br>
     * Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based<br>
     * on the image width, height, strides, and level of chrominance subsampling.<br>
     * Refer to @ref YUVnotes "YUV Image Format Notes" for more details.<br>
     * * @param strides an array of integers, each specifying the number of bytes per<br>
     * line in the corresponding plane of the output image. Setting the stride for<br>
     * any plane to 0 is the same as setting it to the plane width (see<br>
     * 
     * @ref YUVnotes "YUV Image Format Notes".) If <tt>strides</tt> is NULL, then<br>
     *      the strides for all planes will be set to their respective plane widths.<br>
     *      You can adjust the strides in order to add an arbitrary amount of line<br>
     *      padding to each plane or to encode an RGB or grayscale image into a<br>
     *      subregion of a larger YUV planar image.<br>
     *      * @param subsamp the level of chrominance subsampling to be used when<br>
     *      generating the YUV image (see @ref TJSAMP<br>
     *      "Chrominance subsampling options".) To generate images suitable for X<br>
     *      Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420. This produces an<br>
     *      image compatible with the I420 (AKA "YUV420P") format.<br>
     *      * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     *      "flags"<br>
     *      * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     *      Original signature :
     *      <code>int tjEncodeYUVPlanes(tjhandle, const unsigned char*, int, int, int, int, unsigned char**, int*, int, int)</code>
     * <br>
     *      <i>native declaration : line 1028</i>
     */
    public static native int tjEncodeYUVPlanes(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pitch,
            int height, int pixelFormat, Pointer<Pointer<Byte>> dstPlanes, Pointer<Integer> strides, int subsamp,
            int flags);

    /**
     * Create a TurboJPEG decompressor instance.<br>
     * * @return a handle to the newly-created instance, or NULL if an error<br>
     * occurred (see #tjGetErrorStr().)<br>
     * Original signature : <code>tjhandle tjInitDecompress()</code><br>
     * <i>native declaration : line 1040</i>
     */
    public static native Pointer<?> tjInitDecompress();

    /**
     * Retrieve information about a JPEG image without decompressing it.<br>
     * * @param handle a handle to a TurboJPEG decompressor or transformer instance<br>
     * * @param jpegBuf pointer to a buffer containing a JPEG image<br>
     * * @param jpegSize size of the JPEG image (in bytes)<br>
     * * @param width pointer to an integer variable that will receive the width (in<br>
     * pixels) of the JPEG image<br>
     * * @param height pointer to an integer variable that will receive the height<br>
     * (in pixels) of the JPEG image<br>
     * * @param jpegSubsamp pointer to an integer variable that will receive the<br>
     * level of chrominance subsampling used when the JPEG image was compressed<br>
     * (see @ref TJSAMP "Chrominance subsampling options".)<br>
     * * @param jpegColorspace pointer to an integer variable that will receive one<br>
     * of the JPEG colorspace constants, indicating the colorspace of the JPEG<br>
     * image (see @ref TJCS "JPEG colorspaces".)<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjDecompressHeader3(tjhandle, const unsigned char*, unsigned long, int*, int*, int*, int*)</code><br>
     * <i>native declaration : line 1068</i>
     */
    public static native int tjDecompressHeader3(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Integer> width, Pointer<Integer> height,
            Pointer<Integer> jpegSubsamp, Pointer<Integer> jpegColorspace);

    /**
     * Returns a list of fractional scaling factors that the JPEG decompressor in<br>
     * this implementation of TurboJPEG supports.<br>
     * * @param numscalingfactors pointer to an integer variable that will receive<br>
     * the number of elements in the list<br>
     * * @return a pointer to a list of fractional scaling factors, or NULL if an<br>
     * error is encountered (see #tjGetErrorStr().)<br>
     * Original signature : <code>tjscalingfactor* tjGetScalingFactors(int*)</code><br>
     * <i>native declaration : line 1083</i>
     */
    public static native Pointer<TJScalingFactor> tjGetScalingFactors(Pointer<Integer> numscalingfactors);

    /**
     * Decompress a JPEG image to an RGB, grayscale, or CMYK image.<br>
     * * @param handle a handle to a TurboJPEG decompressor or transformer instance<br>
     * * @param jpegBuf pointer to a buffer containing the JPEG image to decompress<br>
     * * @param jpegSize size of the JPEG image (in bytes)<br>
     * * @param dstBuf pointer to an image buffer that will receive the decompressed<br>
     * image. This buffer should normally be <tt>pitch * scaledHeight</tt> bytes<br>
     * in size, where <tt>scaledHeight</tt> can be determined by calling<br>
     * #TJSCALED() with the JPEG image height and one of the scaling factors<br>
     * returned by #tjGetScalingFactors(). The <tt>dstBuf</tt> pointer may also be<br>
     * used to decompress into a specific region of a larger buffer.<br>
     * * @param width desired width (in pixels) of the destination image. If this is<br>
     * different than the width of the JPEG image being decompressed, then<br>
     * TurboJPEG will use scaling in the JPEG decompressor to generate the largest<br>
     * possible image that will fit within the desired width. If <tt>width</tt> is<br>
     * set to 0, then only the height will be considered when determining the<br>
     * scaled image size.<br>
     * * @param pitch bytes per line in the destination image. Normally, this is<br>
     * <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the decompressed image<br>
     * is unpadded, else <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt><br>
     * if each line of the decompressed image is padded to the nearest 32-bit<br>
     * boundary, as is the case for Windows bitmaps. (NOTE: <tt>scaledWidth</tt><br>
     * can be determined by calling #TJSCALED() with the JPEG image width and one<br>
     * of the scaling factors returned by #tjGetScalingFactors().) You can also be<br>
     * clever and use the pitch parameter to skip lines, etc. Setting this<br>
     * parameter to 0 is the equivalent of setting it to<br>
     * <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>.<br>
     * * @param height desired height (in pixels) of the destination image. If this<br>
     * is different than the height of the JPEG image being decompressed, then<br>
     * TurboJPEG will use scaling in the JPEG decompressor to generate the largest<br>
     * possible image that will fit within the desired height. If <tt>height</tt><br>
     * is set to 0, then only the width will be considered when determining the<br>
     * scaled image size.<br>
     * * @param pixelFormat pixel format of the destination image (see @ref<br>
     * TJPF "Pixel formats".)<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjDecompress2(tjhandle, const unsigned char*, unsigned long, unsigned char*, int, int, int, int, int)</code>
     * <br>
     * <i>native declaration : line 1135</i>
     */
    public static native int tjDecompress2(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Byte> dstBuf, int width, int pitch, int height,
            int pixelFormat, int flags);

    /**
     * Decompress a JPEG image to a YUV planar image. This function performs JPEG<br>
     * decompression but leaves out the color conversion step, so a planar YUV<br>
     * image is generated instead of an RGB image.<br>
     * * @param handle a handle to a TurboJPEG decompressor or transformer instance<br>
     * * @param jpegBuf pointer to a buffer containing the JPEG image to decompress<br>
     * * @param jpegSize size of the JPEG image (in bytes)<br>
     * * @param dstBuf pointer to an image buffer that will receive the YUV image.<br>
     * Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based<br>
     * on the image width, height, padding, and level of subsampling. The Y,<br>
     * U (Cb), and V (Cr) image planes will be stored sequentially in the buffer<br>
     * (refer to @ref YUVnotes "YUV Image Format Notes".)<br>
     * * @param width desired width (in pixels) of the YUV image. If this is<br>
     * different than the width of the JPEG image being decompressed, then<br>
     * TurboJPEG will use scaling in the JPEG decompressor to generate the largest<br>
     * possible image that will fit within the desired width. If <tt>width</tt> is<br>
     * set to 0, then only the height will be considered when determining the<br>
     * scaled image size. If the scaled width is not an even multiple of the MCU<br>
     * block width (see #tjMCUWidth), then an intermediate buffer copy will be<br>
     * performed within TurboJPEG.<br>
     * * @param pad the width of each line in each plane of the YUV image will be<br>
     * padded to the nearest multiple of this number of bytes (must be a power of<br>
     * 2.) To generate images suitable for X Video, <tt>pad</tt> should be set to<br>
     * 4.<br>
     * * @param height desired height (in pixels) of the YUV image. If this is<br>
     * different than the height of the JPEG image being decompressed, then<br>
     * TurboJPEG will use scaling in the JPEG decompressor to generate the largest<br>
     * possible image that will fit within the desired height. If <tt>height</tt><br>
     * is set to 0, then only the width will be considered when determining the<br>
     * scaled image size. If the scaled height is not an even multiple of the MCU<br>
     * block height (see #tjMCUHeight), then an intermediate buffer copy will be<br>
     * performed within TurboJPEG.<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjDecompressToYUV2(tjhandle, const unsigned char*, unsigned long, unsigned char*, int, int, int, int)</code>
     * <br>
     * <i>native declaration : line 1185</i>
     */
    public static native int tjDecompressToYUV2(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Byte> dstBuf, int width, int pad, int height, int flags);

    /**
     * Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image<br>
     * planes. This function performs JPEG decompression but leaves out the color<br>
     * conversion step, so a planar YUV image is generated instead of an RGB image.<br>
     * * @param handle a handle to a TurboJPEG decompressor or transformer instance<br>
     * * @param jpegBuf pointer to a buffer containing the JPEG image to decompress<br>
     * * @param jpegSize size of the JPEG image (in bytes)<br>
     * * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes<br>
     * (or just a Y plane, if decompressing a grayscale image) that will receive<br>
     * the YUV image. These planes can be contiguous or non-contiguous in memory.<br>
     * Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based<br>
     * on the scaled image width, scaled image height, strides, and level of<br>
     * chrominance subsampling. Refer to @ref YUVnotes "YUV Image Format Notes"<br>
     * for more details.<br>
     * * @param width desired width (in pixels) of the YUV image. If this is<br>
     * different than the width of the JPEG image being decompressed, then<br>
     * TurboJPEG will use scaling in the JPEG decompressor to generate the largest<br>
     * possible image that will fit within the desired width. If <tt>width</tt> is<br>
     * set to 0, then only the height will be considered when determining the<br>
     * scaled image size. If the scaled width is not an even multiple of the MCU<br>
     * block width (see #tjMCUWidth), then an intermediate buffer copy will be<br>
     * performed within TurboJPEG.<br>
     * * @param strides an array of integers, each specifying the number of bytes per<br>
     * line in the corresponding plane of the output image. Setting the stride for<br>
     * any plane to 0 is the same as setting it to the scaled plane width (see<br>
     * 
     * @ref YUVnotes "YUV Image Format Notes".) If <tt>strides</tt> is NULL, then<br>
     *      the strides for all planes will be set to their respective scaled plane<br>
     *      widths. You can adjust the strides in order to add an arbitrary amount of<br>
     *      line padding to each plane or to decompress the JPEG image into a subregion<br>
     *      of a larger YUV planar image.<br>
     *      * @param height desired height (in pixels) of the YUV image. If this is<br>
     *      different than the height of the JPEG image being decompressed, then<br>
     *      TurboJPEG will use scaling in the JPEG decompressor to generate the largest<br>
     *      possible image that will fit within the desired height. If <tt>height</tt><br>
     *      is set to 0, then only the width will be considered when determining the<br>
     *      scaled image size. If the scaled height is not an even multiple of the MCU<br>
     *      block height (see #tjMCUHeight), then an intermediate buffer copy will be<br>
     *      performed within TurboJPEG.<br>
     *      * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     *      "flags"<br>
     *      * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     *      Original signature :
     *      <code>int tjDecompressToYUVPlanes(tjhandle, const unsigned char*, unsigned long, unsigned char**, int, int*, int, int)</code>
     * <br>
     *      <i>native declaration : line 1241</i>
     */
    public static native int tjDecompressToYUVPlanes(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Pointer<Byte>> dstPlanes, int width, Pointer<Integer> strides,
            int height, int flags);

    /**
     * Decode a YUV planar image into an RGB or grayscale image. This function<br>
     * uses the accelerated color conversion routines in the underlying<br>
     * codec but does not execute any of the other steps in the JPEG decompression<br>
     * process.<br>
     * * @param handle a handle to a TurboJPEG decompressor or transformer instance<br>
     * * @param srcBuf pointer to an image buffer containing a YUV planar image to be<br>
     * decoded. The size of this buffer should match the value returned by<br>
     * #tjBufSizeYUV2() for the given image width, height, padding, and level of<br>
     * chrominance subsampling. The Y, U (Cb), and V (Cr) image planes should be<br>
     * stored sequentially in the source buffer (refer to @ref YUVnotes<br>
     * "YUV Image Format Notes".)<br>
     * * @param pad Use this parameter to specify that the width of each line in each<br>
     * plane of the YUV source image is padded to the nearest multiple of this<br>
     * number of bytes (must be a power of 2.)<br>
     * * @param subsamp the level of chrominance subsampling used in the YUV source<br>
     * image (see @ref TJSAMP "Chrominance subsampling options".)<br>
     * * @param dstBuf pointer to an image buffer that will receive the decoded<br>
     * image. This buffer should normally be <tt>pitch * height</tt> bytes in<br>
     * size, but the <tt>dstBuf</tt> pointer can also be used to decode into a<br>
     * specific region of a larger buffer.<br>
     * * @param width width (in pixels) of the source and destination images<br>
     * * @param pitch bytes per line in the destination image. Normally, this should<br>
     * be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is<br>
     * unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line<br>
     * of the destination image should be padded to the nearest 32-bit boundary, as<br>
     * is the case for Windows bitmaps. You can also be clever and use the pitch<br>
     * parameter to skip lines, etc. Setting this parameter to 0 is the equivalent<br>
     * of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
     * * @param height height (in pixels) of the source and destination images<br>
     * * @param pixelFormat pixel format of the destination image (see @ref TJPF<br>
     * "Pixel formats".)<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjDecodeYUV(tjhandle, const unsigned char*, int, int, unsigned char*, int, int, int, int, int)</code><br>
     * <i>native declaration : line 1293</i>
     */
    public static native int tjDecodeYUV(Pointer<?> handle, Pointer<Byte> srcBuf, int pad, int subsamp,
            Pointer<Byte> dstBuf, int width, int pitch, int height, int pixelFormat, int flags);

    /**
     * Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale<br>
     * image. This function uses the accelerated color conversion routines in the<br>
     * underlying codec but does not execute any of the other steps in the JPEG<br>
     * decompression process.<br>
     * * @param handle a handle to a TurboJPEG decompressor or transformer instance<br>
     * * @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes<br>
     * (or just a Y plane, if decoding a grayscale image) that contain a YUV image<br>
     * to be decoded. These planes can be contiguous or non-contiguous in memory.<br>
     * The size of each plane should match the value returned by #tjPlaneSizeYUV()<br>
     * for the given image width, height, strides, and level of chrominance<br>
     * subsampling. Refer to @ref YUVnotes "YUV Image Format Notes" for more<br>
     * details.<br>
     * * @param strides an array of integers, each specifying the number of bytes per<br>
     * line in the corresponding plane of the YUV source image. Setting the stride<br>
     * for any plane to 0 is the same as setting it to the plane width (see<br>
     * 
     * @ref YUVnotes "YUV Image Format Notes".) If <tt>strides</tt> is NULL, then<br>
     *      the strides for all planes will be set to their respective plane widths.<br>
     *      You can adjust the strides in order to specify an arbitrary amount of line<br>
     *      padding in each plane or to decode a subregion of a larger YUV planar image.<br>
     *      * @param subsamp the level of chrominance subsampling used in the YUV source<br>
     *      image (see @ref TJSAMP "Chrominance subsampling options".)<br>
     *      * @param dstBuf pointer to an image buffer that will receive the decoded<br>
     *      image. This buffer should normally be <tt>pitch * height</tt> bytes in<br>
     *      size, but the <tt>dstBuf</tt> pointer can also be used to decode into a<br>
     *      specific region of a larger buffer.<br>
     *      * @param width width (in pixels) of the source and destination images<br>
     *      * @param pitch bytes per line in the destination image. Normally, this should<br>
     *      be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is<br>
     *      unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line<br>
     *      of the destination image should be padded to the nearest 32-bit boundary, as<br>
     *      is the case for Windows bitmaps. You can also be clever and use the pitch<br>
     *      parameter to skip lines, etc. Setting this parameter to 0 is the equivalent<br>
     *      of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.<br>
     *      * @param height height (in pixels) of the source and destination images<br>
     *      * @param pixelFormat pixel format of the destination image (see @ref TJPF<br>
     *      "Pixel formats".)<br>
     *      * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     *      "flags"<br>
     *      * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     *      Original signature :
     *      <code>int tjDecodeYUVPlanes(tjhandle, const unsigned char**, const int*, int, unsigned char*, int, int, int, int, int)</code>
     * <br>
     *      <i>native declaration : line 1350</i>
     */
    public static native int tjDecodeYUVPlanes(Pointer<?> handle, Pointer<Pointer<Byte>> srcPlanes,
            Pointer<Integer> strides, int subsamp, Pointer<Byte> dstBuf, int width, int pitch, int height,
            int pixelFormat, int flags);

    /**
     * Create a new TurboJPEG transformer instance.<br>
     * * @return a handle to the newly-created instance, or NULL if an error<br>
     * occurred (see #tjGetErrorStr().)<br>
     * Original signature : <code>tjhandle tjInitTransform()</code><br>
     * <i>native declaration : line 1362</i>
     */
    public static native Pointer<?> tjInitTransform();

    /**
     * Losslessly transform a JPEG image into another JPEG image. Lossless<br>
     * transforms work by moving the raw DCT coefficients from one JPEG image<br>
     * structure to another without altering the values of the coefficients. While<br>
     * this is typically faster than decompressing the image, transforming it, and<br>
     * re-compressing it, lossless transforms are not free. Each lossless<br>
     * transform requires reading and performing Huffman decoding on all of the<br>
     * coefficients in the source image, regardless of the size of the destination<br>
     * image. Thus, this function provides a means of generating multiple<br>
     * transformed images from the same source or applying multiple<br>
     * transformations simultaneously, in order to eliminate the need to read the<br>
     * source coefficients multiple times.<br>
     * * @param handle a handle to a TurboJPEG transformer instance<br>
     * * @param jpegBuf pointer to a buffer containing the JPEG source image to<br>
     * transform<br>
     * * @param jpegSize size of the JPEG source image (in bytes)<br>
     * * @param n the number of transformed JPEG images to generate<br>
     * * @param dstBufs pointer to an array of n image buffers. <tt>dstBufs[i]</tt><br>
     * will receive a JPEG image that has been transformed using the parameters in<br>
     * <tt>transforms[i]</tt>. TurboJPEG has the ability to reallocate the JPEG<br>
     * buffer to accommodate the size of the JPEG image. Thus, you can choose to:<br>
     * -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and<br>
     * let TurboJPEG grow the buffer as needed,<br>
     * -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate the buffer<br>
     * for you, or<br>
     * -# pre-allocate the buffer to a "worst case" size determined by calling<br>
     * #tjBufSize() with the transformed or cropped width and height. This should<br>
     * ensure that the buffer never has to be re-allocated (setting<br>
     * #TJFLAG_NOREALLOC guarantees this.)<br>
     * .<br>
     * If you choose option 1, <tt>dstSizes[i]</tt> should be set to the size of<br>
     * your pre-allocated buffer. In any case, unless you have set<br>
     * #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt> upon return<br>
     * from this function, as it may have changed.<br>
     * * @param dstSizes pointer to an array of n unsigned long variables that will<br>
     * receive the actual sizes (in bytes) of each transformed JPEG image. If<br>
     * <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then<br>
     * <tt>dstSizes[i]</tt> should be set to the size of the buffer. Upon return,<br>
     * <tt>dstSizes[i]</tt> will contain the size of the JPEG image (in bytes.)<br>
     * * @param transforms pointer to an array of n #tjtransform structures, each of<br>
     * which specifies the transform parameters and/or cropping region for the<br>
     * corresponding transformed output image.<br>
     * * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP<br>
     * "flags"<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature :
     * <code>int tjTransform(tjhandle, const unsigned char*, unsigned long, int, unsigned char**, unsigned long*, tjtransform*, int)</code>
     * <br>
     * <i>native declaration : line 1420</i>
     */
    public static native int tjTransform(Pointer<?> handle, Pointer<Byte> jpegBuf, @org.bridj.ann.CLong long jpegSize,
            int n, Pointer<Pointer<Byte>> dstBufs, Pointer<org.bridj.CLong> dstSizes, Pointer<TJTransform> transforms,
            int flags);

    /**
     * Destroy a TurboJPEG compressor, decompressor, or transformer instance.<br>
     * * @param handle a handle to a TurboJPEG compressor, decompressor or<br>
     * transformer instance<br>
     * * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)<br>
     * Original signature : <code>int tjDestroy(tjhandle)</code><br>
     * <i>native declaration : line 1434</i>
     */
    public static native int tjDestroy(Pointer<?> handle);

    /**
     * Allocate an image buffer for use with TurboJPEG. You should always use<br>
     * this function to allocate the JPEG destination buffer(s) for #tjCompress2()<br>
     * and #tjTransform() unless you are disabling automatic buffer<br>
     * (re)allocation (by setting #TJFLAG_NOREALLOC.)<br>
     * * @param bytes the number of bytes to allocate<br>
     * * @return a pointer to a newly-allocated buffer with the specified number of<br>
     * bytes.<br>
     * * @sa tjFree()<br>
     * Original signature : <code>char* tjAlloc(int)</code><br>
     * <i>native declaration : line 1450</i>
     */
    public static native Pointer<Byte> tjAlloc(int bytes);

    /**
     * Free an image buffer previously allocated by TurboJPEG. You should always<br>
     * use this function to free JPEG destination buffer(s) that were automatically<br>
     * (re)allocated by #tjCompress2() or #tjTransform() or that were manually<br>
     * allocated using #tjAlloc().<br>
     * * @param buffer address of the buffer to free<br>
     * * @sa tjAlloc()<br>
     * Original signature : <code>void tjFree(unsigned char*)</code><br>
     * <i>native declaration : line 1463</i>
     */
    public static native void tjFree(Pointer<Byte> buffer);

    /**
     * Returns a descriptive error message explaining why the last command failed.<br>
     * * @return a descriptive error message explaining why the last command failed.<br>
     * Original signature : <code>char* tjGetErrorStr()</code><br>
     * <i>native declaration : line 1471</i>
     */
    public static native Pointer<Byte> tjGetErrorStr();

    /**
     * Original signature : <code>long TJBUFSIZE(int, int)</code><br>
     * <i>native declaration : line 1499</i>
     */
    @Name("TJBUFSIZE")
    @org.bridj.ann.CLong
    public static native long tJBUFSIZE(int width, int height);

    /**
     * Original signature : <code>long TJBUFSIZEYUV(int, int, int)</code><br>
     * <i>native declaration : line 1501</i>
     */
    @Name("TJBUFSIZEYUV")
    @org.bridj.ann.CLong
    public static native long tJBUFSIZEYUV(int width, int height, int jpegSubsamp);

    /**
     * Original signature : <code>long tjBufSizeYUV(int, int, int)</code><br>
     * <i>native declaration : line 1504</i>
     */
    @org.bridj.ann.CLong
    public static native long tjBufSizeYUV(int width, int height, int subsamp);

    /**
     * Original signature :
     * <code>int tjCompress(tjhandle, unsigned char*, int, int, int, int, unsigned char*, unsigned long*, int, int, int)</code>
     * <br>
     * <i>native declaration : line 1507</i>
     */
    public static native int tjCompress(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pitch, int height,
            int pixelSize, Pointer<Byte> dstBuf, Pointer<org.bridj.CLong> compressedSize, int jpegSubsamp,
            int jpegQual, int flags);

    /**
     * Original signature :
     * <code>int tjEncodeYUV(tjhandle, unsigned char*, int, int, int, int, unsigned char*, int, int)</code><br>
     * <i>native declaration : line 1511</i>
     */
    public static native int tjEncodeYUV(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pitch, int height,
            int pixelSize, Pointer<Byte> dstBuf, int subsamp, int flags);

    /**
     * Original signature :
     * <code>int tjEncodeYUV2(tjhandle, unsigned char*, int, int, int, int, unsigned char*, int, int)</code><br>
     * <i>native declaration : line 1515</i>
     */
    public static native int tjEncodeYUV2(Pointer<?> handle, Pointer<Byte> srcBuf, int width, int pitch, int height,
            int pixelFormat, Pointer<Byte> dstBuf, int subsamp, int flags);

    /**
     * Original signature : <code>int tjDecompressHeader(tjhandle, unsigned char*, unsigned long, int*, int*)</code><br>
     * <i>native declaration : line 1519</i>
     */
    public static native int tjDecompressHeader(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Integer> width, Pointer<Integer> height);

    /**
     * Original signature :
     * <code>int tjDecompressHeader2(tjhandle, unsigned char*, unsigned long, int*, int*, int*)</code><br>
     * <i>native declaration : line 1522</i>
     */
    public static native int tjDecompressHeader2(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Integer> width, Pointer<Integer> height,
            Pointer<Integer> jpegSubsamp);

    /**
     * Original signature :
     * <code>int tjDecompress(tjhandle, unsigned char*, unsigned long, unsigned char*, int, int, int, int, int)</code><br>
     * <i>native declaration : line 1526</i>
     */
    public static native int tjDecompress(Pointer<?> handle, Pointer<Byte> jpegBuf, @org.bridj.ann.CLong long jpegSize,
            Pointer<Byte> dstBuf, int width, int pitch, int height, int pixelSize, int flags);

    /**
     * Original signature :
     * <code>int tjDecompressToYUV(tjhandle, unsigned char*, unsigned long, unsigned char*, int)</code><br>
     * <i>native declaration : line 1530</i>
     */
    public static native int tjDecompressToYUV(Pointer<?> handle, Pointer<Byte> jpegBuf,
            @org.bridj.ann.CLong long jpegSize, Pointer<Byte> dstBuf, int flags);
}
